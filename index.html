<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BackpackBattles „ÉÅ„Çß„ÇπÈßíÈÖçÁΩÆ„ÉÑ„Éº„É´</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .tool-layout {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 30px;
            align-items: start;
        }

        .piece-palette {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }

        .palette-section {
            margin-bottom: 25px;
        }

        .palette-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }

        .piece-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }

        .piece-item {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: grab;
            transition: all 0.3s;
            user-select: none;
            position: relative;
        }

        .piece-item:hover {
            border-color: #667eea;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .piece-item:active {
            cursor: grabbing;
        }

        .piece-symbol {
            font-size: 32px;
            margin-bottom: 5px;
            display: block;
        }

        .piece-name {
            font-size: 12px;
            color: #666;
        }

        .white-piece {
            color: #333;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }

        .black-piece {
            color: #000;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .chess-board {
            background: #8B4513;
            border-radius: 15px;
            padding: 20px;
            display: inline-block;
            margin: 0 auto;
        }

        .board-grid {
            display: grid;
            grid-template-columns: repeat(9, 60px);
            grid-template-rows: repeat(7, 60px);
            gap: 2px;
        }

        .board-cell {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #654321;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .board-cell.light {
            background: #F0D9B5;
        }

        .board-cell.dark {
            background: #B58863;
        }

        .board-cell.drag-over {
            background: #FFE4B5 !important;
            border: 3px solid #FF6B35 !important;
            transform: scale(1.1);
        }

        .board-cell.occupied {
            background: #E8F5E8;
            border: 2px solid #28a745;
        }

        .board-cell.blocked {
            background: #8B0000 !important;
            border: 2px solid #FF4500 !important;
            position: relative;
        }

        .blocked-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .placed-piece {
            font-size: 40px;
            cursor: grab;
            transition: transform 0.2s;
            user-select: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .placed-piece:hover {
            transform: scale(1.2);
        }

        .placed-piece:active {
            cursor: grabbing;
        }

        .placed-piece.dragging {
            opacity: 0.5;
            transform: scale(0.8);
        }

        .info-panel {
            min-width:280px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .piece-count {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 5px 10px;
            background: white;
            border-radius: 5px;
            font-size: 14px;
        }

        .clear-button {
            width: 100%;
            padding: 12px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 10px;
        }

        .clear-button:hover {
            background: #c82333;
        }

        .score-controls {
            max-height: 1200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
        }

        .score-group {
            margin-bottom: 20px;
        }

        .score-label {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .piece-score-control {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .piece-icon {
            font-size: 20px;
            width: 30px;
            text-align: center;
        }

        .score-input-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .score-input-label {
            font-size: 10px;
            color: #666;
            text-align: center;
        }

        .score-input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
        }

        .score-input:focus {
            border-color: #667eea;
            outline: none;
        }

        .reset-button {
            width: 100%;
            padding: 8px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 10px;
        }

        .reset-button:hover {
            background: #5a6268;
        }

        .coordinates {
            position: absolute;
            font-size: 10px;
            color: #666;
            top: 2px;
            left: 2px;
        }

        .dragging-piece {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            font-size: 40px;
            transform: translate(-50%, -50%);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        @media (max-width: 1200px) {
            .tool-layout {
                grid-template-columns: 300px 1fr 300px;
                gap: 20px;
            }

            .chess-board {
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè∞ BackpackBattles „ÉÅ„Çß„ÇπÈßíÈÖçÁΩÆ„ÉÑ„Éº„É´</h1>

        <div class="tool-layout">
            <!-- Â∑¶ÂÅ¥: Èßí„Éë„É¨„ÉÉ„Éà -->
            <div class="piece-palette">
                <div class="palette-section">
                    <div class="palette-title">‚ö™ ÁôΩÈßí</div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="white-pawn">
                            <span class="piece-symbol white-piece">‚ôô</span>
                            <span class="piece-name">„Éù„Éº„É≥</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="white-knight">
                            <span class="piece-symbol white-piece">‚ôò</span>
                            <span class="piece-name">„Éä„Ç§„Éà</span>
                        </div>
                    </div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="white-bishop">
                            <span class="piece-symbol white-piece">‚ôó</span>
                            <span class="piece-name">„Éì„Ç∑„Éß„ÉÉ„Éó</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="white-rook">
                            <span class="piece-symbol white-piece">‚ôñ</span>
                            <span class="piece-name">„É´„Éº„ÇØ</span>
                        </div>
                    </div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="white-queen">
                            <span class="piece-symbol white-piece">‚ôï</span>
                            <span class="piece-name">„ÇØ„Ç§„Éº„É≥</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="white-king">
                            <span class="piece-symbol white-piece">‚ôî</span>
                            <span class="piece-name">„Ç≠„É≥„Ç∞</span>
                        </div>
                    </div>
                </div>

                <div class="palette-section">
                    <div class="palette-title">‚ö´ ÈªíÈßí</div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="black-pawn">
                            <span class="piece-symbol black-piece">‚ôü</span>
                            <span class="piece-name">„Éù„Éº„É≥</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="black-knight">
                            <span class="piece-symbol black-piece">‚ôû</span>
                            <span class="piece-name">„Éä„Ç§„Éà</span>
                        </div>
                    </div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="black-bishop">
                            <span class="piece-symbol black-piece">‚ôù</span>
                            <span class="piece-name">„Éì„Ç∑„Éß„ÉÉ„Éó</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="black-rook">
                            <span class="piece-symbol black-piece">‚ôú</span>
                            <span class="piece-name">„É´„Éº„ÇØ</span>
                        </div>
                    </div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="black-queen">
                            <span class="piece-symbol black-piece">‚ôõ</span>
                            <span class="piece-name">„ÇØ„Ç§„Éº„É≥</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="black-king">
                            <span class="piece-symbol black-piece">‚ôö</span>
                            <span class="piece-name">„Ç≠„É≥„Ç∞</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ‰∏≠Â§Æ: „ÉÅ„Çß„Çπ„Éú„Éº„Éâ -->
            <div class="chess-board">
                <div class="board-grid" id="chessBoard">
                    <!-- „Éú„Éº„Éâ„ÅØJavaScript„ÅßÁîüÊàê -->
                </div>
            </div>

            <!-- Âè≥ÂÅ¥: ÊÉÖÂ†±„Éë„Éç„É´ -->
            <div class="info-panel">
                <div class="info-section">
                    <div class="info-title">üìä ÈÖçÁΩÆÁµ±Ë®à</div>
                    <div id="pieceStats">
                        <!-- Áµ±Ë®àÊÉÖÂ†±„ÅØJavaScript„ÅßÊõ¥Êñ∞ -->
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">‚öñÔ∏è „Çπ„Ç≥„Ç¢Ë®≠ÂÆö</div>
                    <div class="score-controls">
                        <div class="score-group">
                            <div class="score-label">ÁôΩÈßíË®≠ÂÆö</div>
                            <div id="whiteScoreControls"></div>
                        </div>
                        <div class="score-group">
                            <div class="score-label">ÈªíÈßíË®≠ÂÆö</div>
                            <div id="blackScoreControls"></div>
                        </div>
                        <button class="reset-button" onclick="resetScores()">üîÑ „Éá„Éï„Ç©„É´„Éà„Å´Êàª„Åô</button>
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">üéØ Êìç‰ΩúÊñπÊ≥ï</div>
                    <div style="font-size: 14px; line-height: 1.6;">
                        <p><strong>ÈÖçÁΩÆ:</strong> Â∑¶„ÅÆÈßí„Çí„Éú„Éº„Éâ„Å´„Éâ„É©„ÉÉ„Ç∞</p>
                        <p><strong>ÁßªÂãï:</strong> „Éú„Éº„Éâ‰∏ä„ÅÆÈßí„Çí„Éâ„É©„ÉÉ„Ç∞</p>
                        <p><strong>ÂâäÈô§:</strong> Èßí„Çí„Éú„Éº„ÉâÂ§ñ„Å´„Éâ„É©„ÉÉ„Ç∞</p>
                        <p><strong>ÁΩÆÊèõ:</strong> Èßí„ÅÆ‰∏ä„Å´Âà•„ÅÆÈßí„Çí„Éâ„É≠„ÉÉ„Éó</p>
                        <p><strong>„Éù„Éº„É≥ÂõûËª¢:</strong> „Éù„Éº„É≥„ÇíÂè≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÂõûËª¢</p>
                        <p><strong>ÈÄ≤Ë°å‰∏çÂèØ:</strong> Á©∫„Éû„Çπ„Çí‰∏≠„ÇØ„É™„ÉÉ„ÇØ„ÅßÂàáÊõø</p>
                    </div>
                </div>

                <button class="clear-button" onclick="clearBoard()">üóëÔ∏è „Éú„Éº„Éâ„Çí„ÇØ„É™„Ç¢</button>
            </div>
        </div>
    </div>

    <!-- „Éâ„É©„ÉÉ„Ç∞‰∏≠„ÅÆÈßíË°®Á§∫Áî® -->
    <div id="draggingPiece" class="dragging-piece" style="display: none;"></div>

    <script>
        // Èßí„ÅÆÂÆöÁæ©
        const pieceSymbols = {
            'white-pawn': '‚ôô', 'white-knight': '‚ôò', 'white-bishop': '‚ôó',
            'white-rook': '‚ôñ', 'white-queen': '‚ôï', 'white-king': '‚ôî',
            'black-pawn': '‚ôü', 'black-knight': '‚ôû', 'black-bishop': '‚ôù',
            'black-rook': '‚ôú', 'black-queen': '‚ôõ', 'black-king': '‚ôö'
        };

        const pieceNames = {
            'white-pawn': 'ÁôΩ„Éù„Éº„É≥', 'white-knight': 'ÁôΩ„Éä„Ç§„Éà', 'white-bishop': 'ÁôΩ„Éì„Ç∑„Éß„ÉÉ„Éó',
            'white-rook': 'ÁôΩ„É´„Éº„ÇØ', 'white-queen': 'ÁôΩ„ÇØ„Ç§„Éº„É≥', 'white-king': 'ÁôΩ„Ç≠„É≥„Ç∞',
            'black-pawn': 'Èªí„Éù„Éº„É≥', 'black-knight': 'Èªí„Éä„Ç§„Éà', 'black-bishop': 'Èªí„Éì„Ç∑„Éß„ÉÉ„Éó',
            'black-rook': 'Èªí„É´„Éº„ÇØ', 'black-queen': 'Èªí„ÇØ„Ç§„Éº„É≥', 'black-king': 'Èªí„Ç≠„É≥„Ç∞'
        };

        // „Éú„Éº„ÉâÁä∂ÊÖã
        let board = Array(7).fill().map(() => Array(9).fill(null));
        let blockedCells = new Set(); // "row,col" ÂΩ¢Âºè„ÅßÈÄ≤Ë°å‰∏çÂèØËÉΩ„Çª„É´„ÇíÁÆ°ÁêÜ
        let draggedPiece = null;
        let draggedFromBoard = false;
        let draggedFromCell = null;

        // „Éù„Éº„É≥„ÅÆÂêë„ÅçÁÆ°ÁêÜÔºà„Éá„Éï„Ç©„É´„Éà„ÅØ‰∏äÂêë„ÅçÔºâ
        let pawnDirections = {}; // key: "row,col", value: 0-3 (‰∏ä„ÄÅÂè≥„ÄÅ‰∏ã„ÄÅÂ∑¶)

        // „Éú„Éº„ÉâÂàùÊúüÂåñ
        function initializeBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';

            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = `board-cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    // Â∫ßÊ®ôË°®Á§∫
                    const coords = document.createElement('span');
                    coords.className = 'coordinates';
                    coords.textContent = `${row},${col}`;
                    cell.appendChild(coords);

                    // „Éâ„É≠„ÉÉ„Éó„Ç§„Éô„É≥„Éà
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('drop', handleDrop);
                    cell.addEventListener('dragleave', handleDragLeave);

                    // Âè≥„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÔºà„Éù„Éº„É≥„ÅÆÂõûËª¢Áî®Ôºâ
                    cell.addEventListener('contextmenu', handleRightClick);

                    // ‰∏≠„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÔºàÈÄ≤Ë°å‰∏çÂèØËÉΩË®≠ÂÆöÁî®Ôºâ
                    cell.addEventListener('mousedown', handleMouseDown);

                    boardElement.appendChild(cell);
                }
            }
        }

        // „Éë„É¨„ÉÉ„Éà„ÅÆÈßí„Å´„Éâ„É©„ÉÉ„Ç∞„Ç§„Éô„É≥„Éà„ÇíËøΩÂä†
        function initializePalette() {
            document.querySelectorAll('.piece-item').forEach(item => {
                item.addEventListener('dragstart', handlePaletteDragStart);
                item.addEventListener('dragend', handleDragEnd);
            });
        }

        // „Éë„É¨„ÉÉ„Éà„Åã„Çâ„ÅÆ„Éâ„É©„ÉÉ„Ç∞ÈñãÂßã
        function handlePaletteDragStart(e) {
            draggedPiece = e.target.dataset.piece;
            draggedFromBoard = false;

            const draggingElement = document.getElementById('draggingPiece');
            draggingElement.textContent = pieceSymbols[draggedPiece];
            draggingElement.className = `dragging-piece ${draggedPiece.includes('white') ? 'white-piece' : 'black-piece'}`;

            e.dataTransfer.effectAllowed = 'copy';

            // „Éû„Ç¶„ÇπËøΩÂæì
            document.addEventListener('mousemove', followMouse);
        }

        // „Éú„Éº„Éâ‰∏ä„ÅÆÈßí„ÅÆ„Éâ„É©„ÉÉ„Ç∞ÈñãÂßã
        function handleBoardDragStart(e) {
            const cell = e.target.closest('.board-cell');
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            draggedPiece = board[row][col];
            draggedFromBoard = true;
            draggedFromCell = { row, col };

            const draggingElement = document.getElementById('draggingPiece');
            draggingElement.textContent = pieceSymbols[draggedPiece];
            draggingElement.className = `dragging-piece ${draggedPiece.includes('white') ? 'white-piece' : 'black-piece'}`;

            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';

            document.addEventListener('mousemove', followMouse);
        }

        // „Éû„Ç¶„ÇπËøΩÂæì
        function followMouse(e) {
            const draggingElement = document.getElementById('draggingPiece');
            draggingElement.style.display = 'block';
            draggingElement.style.left = e.clientX + 'px';
            draggingElement.style.top = e.clientY + 'px';
        }

        // „Éâ„É©„ÉÉ„Ç∞„Ç™„Éº„Éê„Éº
        function handleDragOver(e) {
            e.preventDefault();
            e.target.closest('.board-cell').classList.add('drag-over');
        }

        // „Éâ„É©„ÉÉ„Ç∞„É™„Éº„Éñ
        function handleDragLeave(e) {
            e.target.closest('.board-cell').classList.remove('drag-over');
        }

        // „Éâ„É≠„ÉÉ„Éó
        function handleDrop(e) {
            e.preventDefault();
            const cell = e.target.closest('.board-cell');
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // ÈÄ≤Ë°å‰∏çÂèØËÉΩ„Çª„É´„Å´„ÅØÈÖçÁΩÆ„Åß„Åç„Å™„ÅÑ
            if (isBlocked(row, col)) {
                cell.classList.remove('drag-over');
                return;
            }

            // ÂÖÉ„ÅÆ‰ΩçÁΩÆ„Åã„ÇâÈßí„ÇíÂâäÈô§Ôºà„Éú„Éº„Éâ„Åã„Çâ„ÅÆÁßªÂãï„ÅÆÂ†¥ÂêàÔºâ
            if (draggedFromBoard && draggedFromCell) {
                // **IDÁßªË°åÂá¶ÁêÜ„ÇíËøΩÂä†**
                const fromKey = `${draggedFromCell.row},${draggedFromCell.col}`;
                const toKey = `${row},${col}`;

                // ÁßªÂãïÂÖÉ„Å´ID„Åå„ÅÇ„Çå„Å∞ÁßªÂãïÂÖà„Å´ÁßªË°å
                if (pieceIds[fromKey]) {
                    pieceIds[toKey] = pieceIds[fromKey];
                    delete pieceIds[fromKey];

                    // „Éù„Éº„É≥„ÅÆÂêë„ÅçÊÉÖÂ†±„ÇÇ‰∏ÄÁ∑í„Å´ÁßªË°å
                    if (pawnDirections[fromKey]) {
                        pawnDirections[toKey] = pawnDirections[fromKey];
                        delete pawnDirections[fromKey];
                    }
                }
                board[draggedFromCell.row][draggedFromCell.col] = null;
                updateCellDisplay(draggedFromCell.row, draggedFromCell.col);
            }

            // Êñ∞„Åó„ÅÑ‰ΩçÁΩÆ„Å´Èßí„ÇíÈÖçÁΩÆ
            board[row][col] = draggedPiece;
            updateCellDisplay(row, col);

            cell.classList.remove('drag-over');
            updateStats();
        }

        // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫Ü
        function handleDragEnd(e) {
            document.removeEventListener('mousemove', followMouse);
            document.getElementById('draggingPiece').style.display = 'none';

            // „Éâ„É©„ÉÉ„Ç∞‰∏≠„ÅÆË°®Á§∫„Çí„É™„Çª„ÉÉ„Éà
            document.querySelectorAll('.board-cell').forEach(cell => {
                cell.classList.remove('drag-over');
            });

            document.querySelectorAll('.placed-piece').forEach(piece => {
                piece.classList.remove('dragging');
            });

            // „Éú„Éº„ÉâÂ§ñ„Å´„Éâ„É≠„ÉÉ„Éó„Åó„ÅüÂ†¥Âêà„ÅÆÂâäÈô§Âá¶ÁêÜ
            if (draggedFromBoard && draggedFromCell) {
                const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
                if (!dropTarget || !dropTarget.closest('.board-cell')) {
                    // „Éú„Éº„ÉâÂ§ñ„Å´„Éâ„É≠„ÉÉ„Éó = ÂâäÈô§
                    board[draggedFromCell.row][draggedFromCell.col] = null;
                    updateCellDisplay(draggedFromCell.row, draggedFromCell.col);
                    updateStats();
                }
            }

            draggedPiece = null;
            draggedFromBoard = false;
            draggedFromCell = null;
        }

        // „Çª„É´„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
        function updateCellDisplay(row, col) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const existingPiece = cell.querySelector('.placed-piece');
            const existingBlocked = cell.querySelector('.blocked-marker');

            if (existingPiece) {
                existingPiece.remove();
            }
            if (existingBlocked) {
                existingBlocked.remove();
            }

            // ÈÄ≤Ë°å‰∏çÂèØËÉΩ„Çª„É´„ÅÆË°®Á§∫
            if (isBlocked(row, col)) {
                const blockedMarker = document.createElement('span');
                blockedMarker.className = 'blocked-marker';
                blockedMarker.textContent = '‚õî';
                cell.appendChild(blockedMarker);
                cell.classList.add('blocked');
                cell.classList.remove('occupied');
                return;
            } else {
                cell.classList.remove('blocked');
            }

            if (board[row][col]) {
                const piece = board[row][col];
                const pieceElement = document.createElement('span');
                pieceElement.className = `placed-piece ${piece.includes('white') ? 'white-piece' : 'black-piece'}`;

                const cellKey = `${row},${col}`;

                // Êñ∞Ë¶èÈÖçÁΩÆ„ÅÆÂ†¥Âêà„ÅÆ„ÅøID‰ªò‰∏é
                if (!pieceIds[cellKey]) {
                    pieceIds[cellKey] = ++pieceIdCounter;
                }

                // „Éù„Éº„É≥„ÅÆÂ†¥Âêà„ÅØÂêë„Åç„ÇíÂèçÊò†„Åó„ÅüË°®Á§∫
                if (piece.includes('pawn')) {
                    const pawnKey = `${row},${col}`;
                    const direction = pawnDirections[pawnKey] || 0;

                    // „Éù„Éº„É≥„ÅÆÂü∫Êú¨Ë®òÂè∑„Çí‰ΩøÁî®
                    pieceElement.textContent = pieceSymbols[piece];

                    // Âêë„Åç„ÇíË¶ñË¶öÁöÑ„Å´Á§∫„Åô„Åü„ÇÅ„ÅÆÂõûËª¢
                    const rotations = ['0deg', '90deg', '180deg', '270deg'];
                    pieceElement.style.transform = `rotate(${rotations[direction]})`;
                    pieceElement.style.transformOrigin = 'center';
                    pieceElement.style.display = 'inline-block'; // ÂõûËª¢„ÅÆ„Åü„ÇÅ„Å´ÂøÖË¶Å
                } else {
                    pieceElement.textContent = pieceSymbols[piece];
                }

                pieceElement.draggable = true;

                pieceElement.addEventListener('dragstart', handleBoardDragStart);
                pieceElement.addEventListener('dragend', handleDragEnd);

                cell.appendChild(pieceElement);
                cell.classList.add('occupied');
            } else {
                // Èßí„ÅåÂâäÈô§„Åï„Çå„ÅüÂ†¥Âêà„ÅØID„ÇÇÂâäÈô§
                const cellKey = `${row},${col}`;
                delete pieceIds[cellKey];

                cell.classList.remove('occupied');
            }
        }
        let pieceIdCounter = 0;
        let pieceIds = {}; // (row,col) -> unique_id „ÅÆ„Éû„ÉÉ„Éî„É≥„Ç∞

        function assignPieceId(row, col) {
            const key = `${row},${col}`;
            if (!pieceIds[key]) {
                pieceIds[key] = ++pieceIdCounter;
            }
            return pieceIds[key];
        }

        function movePieceWithId(fromRow, fromCol, toRow, toCol) {
            const fromKey = `${fromRow},${fromCol}`;
            const toKey = `${toRow},${toCol}`;

            // ID„ÇíÊñ∞„Åó„ÅÑ‰ΩçÁΩÆ„Å´ÁßªË°å
            if (pieceIds[fromKey]) {
                pieceIds[toKey] = pieceIds[fromKey];
                delete pieceIds[fromKey];
            }
        }

        // ‰∏≠„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÔºàÈÄ≤Ë°å‰∏çÂèØËÉΩË®≠ÂÆöÔºâ
        function handleMouseDown(e) {
            if (e.button === 1) { // ‰∏≠„ÇØ„É™„ÉÉ„ÇØ
                e.preventDefault();
                const cell = e.target.closest('.board-cell');
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                toggleBlockedCell(row, col);
            }
        }

        // ‰∏≠„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÔºàÈÄ≤Ë°å‰∏çÂèØËÉΩË®≠ÂÆöÔºâ
        function handleMouseDown(e) {
            if (e.button === 1) { // ‰∏≠„ÇØ„É™„ÉÉ„ÇØ
                e.preventDefault();
                const cell = e.target.closest('.board-cell');
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                toggleBlockedCell(row, col);
            }
        }

        // ÈÄ≤Ë°å‰∏çÂèØËÉΩ„Çª„É´„ÅÆÂàá„ÇäÊõø„Åà
        function toggleBlockedCell(row, col) {
            const cellKey = `${row},${col}`;

            if (isBlocked(row, col)) {
                // ÈÄ≤Ë°å‰∏çÂèØËÉΩ„ÇíËß£Èô§
                blockedCells.delete(cellKey);
            } else {
                // Èßí„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂÖà„Å´Èßí„ÇíÂâäÈô§
                if (board[row][col]) {
                    board[row][col] = null;
                    // „Éù„Éº„É≥„ÅÆÂêë„ÅçÊÉÖÂ†±„ÇÇÂâäÈô§
                    delete pawnDirections[cellKey];
                }
                // ÈÄ≤Ë°å‰∏çÂèØËÉΩ„Å´Ë®≠ÂÆö
                blockedCells.add(cellKey);
            }

            updateCellDisplay(row, col);
            updateStats();
        }

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÔºà„Éù„Éº„É≥„ÅÆÂõûËª¢Ôºâ
        function handleRightClick(e) {
            e.preventDefault(); // „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº„ÇíË°®Á§∫„Åó„Å™„ÅÑ

            const cell = e.target.closest('.board-cell');
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const piece = board[row][col];

            // „Éù„Éº„É≥„ÅÆÂ†¥Âêà„ÅÆ„ÅøÂõûËª¢Âá¶ÁêÜ
            if (piece && piece.includes('pawn')) {
                const pawnKey = `${row},${col}`;
                const currentDirection = pawnDirections[pawnKey] || 0;

                // ÊôÇË®àÂõû„Çä„Å´ÂõûËª¢Ôºà0‚Üí1‚Üí2‚Üí3‚Üí0Ôºâ
                pawnDirections[pawnKey] = (currentDirection + 1) % 4;

                // Ë°®Á§∫„ÇíÊõ¥Êñ∞
                updateCellDisplay(row, col);

                // Ë©ï‰æ°„ÇíÂÜçË®àÁÆó
                updateStats();
            }
        }

        // Èßí„ÅÆ‰æ°ÂÄ§ÂÆöÁæ©Ôºà„Éá„Éï„Ç©„É´„ÉàÂÄ§Ôºâ
        const defaultPieceValues = {
            'white-pawn': [1, 1], 'white-knight': [3, 3], 'white-bishop': [3, 3],
            'white-rook': [5, 5], 'white-queen': [9, 9], 'white-king': [4, 2],
            'black-pawn': [1, 1], 'black-knight': [3, 3], 'black-bishop': [3, 3],
            'black-rook': [5, 5], 'black-queen': [9, 9], 'black-king': [4, 2]
        };

        // ÁèæÂú®„ÅÆÈßí„ÅÆ‰æ°ÂÄ§Ôºà„É¶„Éº„Ç∂„Éº„ÅåÂ§âÊõ¥ÂèØËÉΩÔºâ
        let pieceValues = JSON.parse(JSON.stringify(defaultPieceValues));

        const pieceTypeNames = {
            'pawn': '„Éù„Éº„É≥',
            'knight': '„Éä„Ç§„Éà',
            'bishop': '„Éì„Ç∑„Éß„ÉÉ„Éó',
            'rook': '„É´„Éº„ÇØ',
            'queen': '„ÇØ„Ç§„Éº„É≥',
            'king': '„Ç≠„É≥„Ç∞'
        };

        // „Çπ„Ç≥„Ç¢Ë®≠ÂÆöUI„ÅÆÂàùÊúüÂåñ
        function initializeScoreControls() {
            const whiteContainer = document.getElementById('whiteScoreControls');
            const blackContainer = document.getElementById('blackScoreControls');

            const pieceTypes = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'];

            pieceTypes.forEach(type => {
                // ÁôΩÈßíÁî®
                const whiteDiv = document.createElement('div');
                whiteDiv.className = 'piece-score-control';

                if (type === 'king') {
                    // „Ç≠„É≥„Ç∞„ÅØËá™ËªçÂäπÊûú„ÅÆË®≠ÂÆö
                    whiteDiv.innerHTML = `
                        <div class="piece-icon white-piece">${pieceSymbols['white-' + type]}</div>
                        <div class="score-input-group">
                            <div class="score-input-label">Âèñ„ÇãÊôÇ</div>
                            <input type="number" class="score-input" id="white-${type}-capture"
                                   value="${pieceValues['white-' + type][0]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('white-${type}', 0, this.value)">
                        </div>
                        <div class="score-input-group">
                            <div class="score-input-label">Ëá™ËªçÂäπÊûú</div>
                            <input type="number" class="score-input" id="white-${type}-captured"
                                   value="${pieceValues['white-' + type][1]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('white-${type}', 1, this.value)">
                        </div>
                    `;
                } else {
                    whiteDiv.innerHTML = `
                        <div class="piece-icon white-piece">${pieceSymbols['white-' + type]}</div>
                        <div class="score-input-group">
                            <div class="score-input-label">Âèñ„ÇãÊôÇ</div>
                            <input type="number" class="score-input" id="white-${type}-capture"
                                   value="${pieceValues['white-' + type][0]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('white-${type}', 0, this.value)">
                        </div>
                        <div class="score-input-group">
                            <div class="score-input-label">Âèñ„Çâ„Çå„ÇãÊôÇ</div>
                            <input type="number" class="score-input" id="white-${type}-captured"
                                   value="${pieceValues['white-' + type][1]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('white-${type}', 1, this.value)">
                        </div>
                    `;
                }
                whiteContainer.appendChild(whiteDiv);

                // ÈªíÈßíÁî®
                const blackDiv = document.createElement('div');
                blackDiv.className = 'piece-score-control';

                if (type === 'king') {
                    // „Ç≠„É≥„Ç∞„ÅØËá™ËªçÂäπÊûú„ÅÆË®≠ÂÆö
                    blackDiv.innerHTML = `
                        <div class="piece-icon black-piece">${pieceSymbols['black-' + type]}</div>
                        <div class="score-input-group">
                            <div class="score-input-label">Âèñ„ÇãÊôÇ</div>
                            <input type="number" class="score-input" id="black-${type}-capture"
                                   value="${pieceValues['black-' + type][0]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('black-${type}', 0, this.value)">
                        </div>
                        <div class="score-input-group">
                            <div class="score-input-label">Ëá™ËªçÂäπÊûú</div>
                            <input type="number" class="score-input" id="black-${type}-captured"
                                   value="${pieceValues['black-' + type][1]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('black-${type}', 1, this.value)">
                        </div>
                    `;
                } else {
                    blackDiv.innerHTML = `
                        <div class="piece-icon black-piece">${pieceSymbols['black-' + type]}</div>
                        <div class="score-input-group">
                            <div class="score-input-label">Âèñ„ÇãÊôÇ</div>
                            <input type="number" class="score-input" id="black-${type}-capture"
                                   value="${pieceValues['black-' + type][0]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('black-${type}', 0, this.value)">
                        </div>
                        <div class="score-input-group">
                            <div class="score-input-label">Âèñ„Çâ„Çå„ÇãÊôÇ</div>
                            <input type="number" class="score-input" id="black-${type}-captured"
                                   value="${pieceValues['black-' + type][1]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('black-${type}', 1, this.value)">
                        </div>
                    `;
                }
                blackContainer.appendChild(blackDiv);
            });
        }

        // Èßí„ÅÆ‰æ°ÂÄ§Êõ¥Êñ∞
        function updatePieceValue(pieceKey, valueIndex, newValue) {
            const value = parseFloat(newValue) || 0;
            pieceValues[pieceKey][valueIndex] = value;
            updateStats(); // Áµ±Ë®à„ÇíÂÜçË®àÁÆó
        }

        // „Çπ„Ç≥„Ç¢„Çí„Éá„Éï„Ç©„É´„Éà„Å´„É™„Çª„ÉÉ„Éà
        function resetScores() {
            if (confirm('ÂäπÊûúÂÄ§„Çí„Éá„Éï„Ç©„É´„Éà„Å´Êàª„Åó„Åæ„Åô„ÅãÔºü')) {
                pieceValues = JSON.parse(JSON.stringify(defaultPieceValues));

                // UIÊõ¥Êñ∞
                Object.keys(pieceValues).forEach(pieceKey => {
                    const [color, type] = pieceKey.split('-');
                    document.getElementById(`${color}-${type}-capture`).value = pieceValues[pieceKey][0];
                    document.getElementById(`${color}-${type}-captured`).value = pieceValues[pieceKey][1];
                });

                updateStats();
            }
        }

        // Èßí„ÅÆÁßªÂãï„Éë„Çø„Éº„É≥ÂèñÂæó
        function getPossibleMoves(piece, row, col, currentBoard = board, currentPawnDirections = pawnDirections) {
            const moves = [];
            const pieceType = piece.split('-')[1];

            switch (pieceType) {
                case 'pawn':
                    // „Éù„Éº„É≥: Âêë„Åç„Å´Âøú„Åò„ÅüÊñú„ÇÅÂâç2ÊñπÂêë
                    const pawnKey = `${row},${col}`;
                    const direction = currentPawnDirections[pawnKey] || 0; // „Éá„Éï„Ç©„É´„Éà„ÅØ‰∏äÂêë„Åç

                    // Âêë„Åç„Åî„Å®„ÅÆÊñú„ÇÅÂâçÊñπÂêëÂÆöÁæ©
                    const pawnDirectionMoves = [
                        [[-1, -1], [-1, 1]], // ‰∏äÂêë„Åç
                        [[1, 1], [-1, 1]],   // Âè≥Âêë„Åç
                        [[1, -1], [1, 1]],   // ‰∏ãÂêë„Åç
                        [[-1, -1], [1, -1]]  // Â∑¶Âêë„Åç
                    ];

                    const pawnMoves = pawnDirectionMoves[direction];
                    pawnMoves.forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (isValidPosition(newRow, newCol) && !isBlocked(newRow, newCol)) {
                            const targetPiece = currentBoard[newRow][newCol];
                            if (!targetPiece || getColor(targetPiece) !== getColor(piece)) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    });
                    break;

                case 'knight':
                    // „Éä„Ç§„Éà: LÂ≠óÁßªÂãï
                    const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                    knightMoves.forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (isValidPosition(newRow, newCol) && !isBlocked(newRow, newCol)) {
                            const targetPiece = currentBoard[newRow][newCol];
                            if (!targetPiece || getColor(targetPiece) !== getColor(piece)) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    });
                    break;

                case 'bishop':
                    // „Éì„Ç∑„Éß„ÉÉ„Éó: Êñú„ÇÅ
                addSlidingMoves(moves, row, col, [[-1,-1], [-1,1], [1,-1], [1,1]], piece, currentBoard);
                    break;

                case 'rook':
                    // „É´„Éº„ÇØ: ÂâçÂæåÂ∑¶Âè≥
                addSlidingMoves(moves, row, col, [[-1,0], [1,0], [0,-1], [0,1]], piece, currentBoard);
                    break;

                case 'queen':
                    // „ÇØ„Ç§„Éº„É≥: ÂÖ®ÊñπÂêë
                addSlidingMoves(moves, row, col, [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]], piece, currentBoard);
                    break;

                case 'king':
                    // „Ç≠„É≥„Ç∞: ÂÖ®ÊñπÂêë1„Éû„Çπ
                    const kingMoves = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
                    kingMoves.forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (isValidPosition(newRow, newCol) && !isBlocked(newRow, newCol)) {
                            const targetPiece = currentBoard[newRow][newCol];
                            if (!targetPiece || getColor(targetPiece) !== getColor(piece)) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    });
                    break;
            }

            return moves;
        }

        function addSlidingMoves(moves, row, col, directions, piece, currentBoard = board) {
            directions.forEach(([dr, dc]) => {
                for (let i = 1; i < 9; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;

                    // Áõ§Èù¢Â§ñ„Å™„ÇâÂÅúÊ≠¢
                    if (!isValidPosition(newRow, newCol)) break;

                    // ÈÄ≤Ë°å‰∏çÂèØËÉΩ„Éû„Çπ„Å´„ÅØÁßªÂãï„Åß„Åç„Å™„ÅÑ„Åå„ÄÅÈÄöÈÅé„ÅØÂèØËÉΩ
                    if (!isBlocked(newRow, newCol)) {
                        const targetPiece = currentBoard[newRow][newCol];
                        if (!targetPiece || getColor(targetPiece) !== getColor(piece)) {
                            moves.push([newRow, newCol]);
                        }
                    }
                    // Èßí„Åå„ÅÇ„Å£„Å¶„ÇÇÈ£õ„Å≥Ë∂ä„Åà„Å¶ÁßªÂãïÂèØËÉΩÔºàBackpackBattles„É´„Éº„É´Ôºâ
                }
            });
        }

        function isValidPosition(row, col) {
            return row >= 0 && row < 7 && col >= 0 && col < 9;
        }

        function isBlocked(row, col) {
            return blockedCells.has(`${row},${col}`);
        }

        function getColor(piece) {
            return piece ? piece.split('-')[0] : null;
        }

        function getOppositeColor(color) {
            return color === 'white' ? 'black' : 'white';
        }

        function logAllPieces(currentBoard) {
            console.log("=== ÁèæÂú®„ÅÆÁõ§Èù¢„ÅÆÈßí‰∏ÄË¶ß ===");
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = currentBoard[row][col];
                    if (piece) {
                        console.log(`${piece} at (${row}, ${col})`);
                    }
                }
            }
        }

        // Áõ§Èù¢Ë©ï‰æ°Èñ¢Êï∞
        function evaluateBoard(boardState = null, pawnState = null, depth = 0, turn = 'white', maxDepth = 3, firstCapture = null) {
            if (depth >= maxDepth) return 0;

            const currentBoard = boardState || board;
            const currentPawnDirections = pawnState || pawnDirections;
            let totalScore = 0;
            let candidateNum = 0;

            // ÂàùÂõûÊà¶Èóò„Éï„É©„Ç∞„ÅÆÂàùÊúüÂåñÔºàÂÄãÂà•Èßí„Åî„Å®Ôºâ
            if (firstCapture === null) {
                firstCapture = new Set();
            }

            // ÊåáÂÆöËâ≤„ÅÆÂÖ®Èßí„Å´„Å§„ÅÑ„Å¶Ë©ï‰æ°
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = currentBoard[row][col];
                    if (!piece || getColor(piece) !== turn) continue;

                    const moves = getPossibleMoves(piece, row, col, currentBoard, currentPawnDirections);

                    for (const [newRow, newCol] of moves) {
                        const eliminatePiece = currentBoard[newRow][newCol];
                        if (eliminatePiece) {
                            candidateNum++;

                            // „Çπ„Ç≥„Ç¢Ë®àÁÆó
                            let score = 0;

                            // Âèñ„ÇãÈßí„ÅÆÂü∫Êú¨ÂäπÊûú
                            score += pieceValues[piece][0];

                            // „Ç≠„É≥„Ç∞„ÅØÂèñ„Çâ„Çå„ÇãÂäπÊûú„Å™„Åó„ÄÅ„Åù„ÅÆ‰ªñ„ÅØÂèñ„Çâ„Çå„ÇãÂäπÊûú„ÅÇ„Çä
                            if (!eliminatePiece.includes('king')) {
                                score += pieceValues[eliminatePiece][1];
                            }

                            // „Ç≠„É≥„Ç∞„ÅÆËá™ËªçÂäπÊûú„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                            let countKingSupport = countAllyKings(currentBoard, getColor(piece));

                            if (countKingSupport > 0) {
                                // „Ç≠„É≥„Ç∞„ÅÆËá™ËªçÂäπÊûú„ÇíËøΩÂä†
                                const kingPiece = getColor(piece) === 'white' ? 'white-king' : 'black-king';
                                const kingBonus = countKingSupport * pieceValues[kingPiece][1]; // „Ç≠„É≥„Ç∞„ÅÆËá™ËªçÂäπÊûú„ÅØ[1]„Å´Ë®≠ÂÆö

                                // ÂÄãÂà•Èßí„ÅÆÂàùÂõûÊà¶Èóò„ÅÆÂ†¥Âêà„ÅØ2ÂÄç
                                const cellKey = `${row},${col}`;
                                const pieceId = pieceIds[cellKey];
                                const firstCaptureKey = `${pieceId}`;

                                if (pieceId && !firstCapture.has(firstCaptureKey)) {
                                    score += kingBonus * 2;
                                    // Êñ∞„Åó„ÅÑSet„Çí‰ΩúÊàê„Åó„Å¶Áä∂ÊÖã„ÇíÊõ¥Êñ∞
                                    const newFirstCapture = new Set(firstCapture);
                                    newFirstCapture.add(firstCaptureKey);

                                    // Áõ§Èù¢„Çí„Ç≥„Éî„Éº„Åó„Å¶ÁßªÂãï„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
                                    const newBoard = currentBoard.map(row => [...row]);
                                    const newPawnDirections = { ...currentPawnDirections}
                                    if (piece.includes('pawn')){
                                        newBoard[newRow][newCol] = piece;
                                        newBoard[row][col] = null;
                                        newPawnDirections[`${newRow},${newCol}`] = newPawnDirections[`${row},${col}`];
                                        delete newPawnDirections[`${row},${col}`];
                                    } else {
                                        newBoard[newRow][newCol] = piece;
                                        newBoard[row][col] = null;
                                    }

                                    // ÂÜçÂ∏∞Ë©ï‰æ°ÔºàÊõ¥Êñ∞„Åï„Çå„ÅüÂàùÂõûÊà¶Èóò„Éï„É©„Ç∞„ÇíÂºï„ÅçÁ∂ô„ÅéÔºâ
                                    score += evaluateBoard(newBoard, newPawnDirectory, depth+1, getOppositeColor(turn), maxDepth, newFirstCapture);
                                } else {
                                    score += kingBonus;

                                    // Áõ§Èù¢„Çí„Ç≥„Éî„Éº„Åó„Å¶ÁßªÂãï„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
                                    const newBoard = currentBoard.map(row => [...row]);
                                    const newPawnDirections = { ...currentPawnDirections}
                                    if (piece.includes('pawn')){
                                        newBoard[newRow][newCol] = piece;
                                        newBoard[row][col] = null;
                                        newPawnDirections[`${newRow},${newCol}`] = newPawnDirections[`${row},${col}`];
                                        delete newPawnDirections[`${row},${col}`];
                                    } else {
                                        newBoard[newRow][newCol] = piece;
                                        newBoard[row][col] = null;
                                    }
                                    // ÂÜçÂ∏∞Ë©ï‰æ°
                                    score += evaluateBoard(newBoard, newPawnDirections, depth+1, getOppositeColor(turn), maxDepth, new Set(firstCapture));
                                }
                            } else {
                                // „Ç≠„É≥„Ç∞„Çµ„Éù„Éº„Éà„Å™„Åó„ÅÆÂ†¥Âêà
                                // Áõ§Èù¢„Çí„Ç≥„Éî„Éº„Åó„Å¶ÁßªÂãï„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
                                const newBoard = currentBoard.map(row => [...row]);
                                const newPawnDirections = { ...currentPawnDirections};
                                if (piece.includes('pawn')){
                                    newBoard[newRow][newCol] = piece;
                                    newBoard[row][col] = null;
                                    newPawnDirections[`${newRow},${newCol}`] = newPawnDirections[`${row},${col}`];
                                    delete newPawnDirections[`${row},${col}`];
                                } else {
                                    newBoard[newRow][newCol] = piece;
                                    newBoard[row][col] = null;
                                }

                                // ÂÜçÂ∏∞Ë©ï‰æ°
                                score += evaluateBoard(newBoard, newPawnDirections, depth+1, getOppositeColor(turn), maxDepth, new Set(firstCapture));
                            }

                            totalScore += score;
                        }
                    }
                }
            }


            // ÂèñÂæó„Åß„Åç„ÇãÁßªÂãïÂÖà„Åå„Å™„ÅÑÂ†¥Âêà
            if (candidateNum == 0) {
                // „É©„É≥„ÉÄ„É†„Å´ÁßªÂãï
                // ÊåáÂÆöËâ≤„ÅÆÂÖ®Èßí„Å´„Å§„ÅÑ„Å¶Ë©ï‰æ°
                for (let row = 0; row < 7; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = currentBoard[row][col];
                        if (!piece || getColor(piece) !== turn) continue;
                        const moves = getPossibleMoves(piece, row, col, currentBoard, currentPawnDirections);

                        for (const [newRow, newCol] of moves) {
                            candidateNum++;

                            // Áõ§Èù¢„Çí„Ç≥„Éî„Éº„Åó„Å¶ÁßªÂãï„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
                            const newBoard = currentBoard.map(row => [...row]);
                            const newPawnDirections = { ...currentPawnDirections};
                            if (piece.includes('pawn')){
                                newBoard[newRow][newCol] = piece;
                                newBoard[row][col] = null;
                                newPawnDirections[`${newRow},${newCol}`] = newPawnDirections[`${row},${col}`];
                                delete newPawnDirections[`${row},${col}`];
                            } else {
                                newBoard[newRow][newCol] = piece;
                                newBoard[row][col] = null;
                            }
                            // ÂÜçÂ∏∞Ë©ï‰æ°
                            let score = 0;
                            score += evaluateBoard(newBoard, newPawnDirections, depth+1, getOppositeColor(turn), maxDepth, new Set(firstCapture));
                            totalScore += score;
                        }
                    }
                }
            }
            if (candidateNum > 0){
                totalScore /= candidateNum
                return totalScore;
            }

            // ÁßªÂãï„Åß„Åç„ÇãÈßí„Åå„Å™„ÅÑÂ†¥Âêà
            let score = 0;
            const newBoard = currentBoard.map(row => [...row]);
            score += evaluateBoard(newBoard, { ... currentPawnDirections}, depth+1, getOppositeColor(turn), maxDepth, new Set(firstCapture));
            totalScore += score;

            return totalScore;
        }

        // Ëá™Ëªç„Ç≠„É≥„Ç∞„ÅÆÊï∞„Çí„Ç´„Ç¶„É≥„Éà
        function countAllyKings(boardState, color) {
            let kingCount = 0;
            // Áõ§Èù¢ÂÖ®‰Ωì„ÅßËá™Ëªç„Ç≠„É≥„Ç∞„ÇíÊé¢Á¥¢
            for (let r = 0; r < 7; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = boardState[r][c];
                    if (piece && piece.includes('king') && getColor(piece) === color) {
                        kingCount++;
                    }
                }
            }
            return kingCount;
        }

        // Áµ±Ë®àÊõ¥Êñ∞
        function updateStats() {
            const stats = {};
            const colors = { white: 0, black: 0 };

            // Èßí„Çí„Ç´„Ç¶„É≥„Éà
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col]) {
                        const piece = board[row][col];
                        stats[piece] = (stats[piece] || 0) + 1;

                        if (piece.includes('white')) colors.white++;
                        else colors.black++;
                    }
                }
            }

            // Áõ§Èù¢Ë©ï‰æ°„Çπ„Ç≥„Ç¢Ë®àÁÆóÔºàÁôΩÊâãÁï™ÈñãÂßãÔºâ
            const boardScore = evaluateBoard(null, null, 0, 'white', 5);

            // Áµ±Ë®àË°®Á§∫„ÇíÊõ¥Êñ∞
            const statsElement = document.getElementById('pieceStats');
            let html = '';

            // Ëâ≤Âà•Áµ±Ë®à
            html += `<div class="piece-count"><strong>ÁôΩÈßíÁ∑èÊï∞:</strong> <span>${colors.white}</span></div>`;
            html += `<div class="piece-count"><strong>ÈªíÈßíÁ∑èÊï∞:</strong> <span>${colors.black}</span></div>`;
            html += `<div class="piece-count"><strong>„Éê„É©„É≥„ÇπÂ∑Æ:</strong> <span>${Math.abs(colors.white - colors.black)}</span></div>`;

            html += '<hr style="margin: 10px 0;">';

            // Áõ§Èù¢Ë©ï‰æ°„Çπ„Ç≥„Ç¢
            html += `<div class="piece-count"><strong>Áõ§Èù¢Ë©ï‰æ°:</strong> <span>${boardScore.toFixed(1)}</span></div>`;

            html += '<hr style="margin: 10px 0;">';

            // ÂÄãÂà•ÈßíÁµ±Ë®à
            Object.keys(pieceNames).forEach(piece => {
                if (stats[piece]) {
                    html += `<div class="piece-count">
                        <span>${pieceNames[piece]}:</span>
                        <span>${stats[piece]}</span>
                    </div>`;
                }
            });

            statsElement.innerHTML = html;
        }

        // „Éú„Éº„Éâ„ÇØ„É™„Ç¢
        function clearBoard() {
            if (confirm('„Éú„Éº„Éâ„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) {
                board = Array(7).fill().map(() => Array(9).fill(null));
                blockedCells.clear(); // ÈÄ≤Ë°å‰∏çÂèØËÉΩ„Çª„É´ÊÉÖÂ†±„Çí„ÇØ„É™„Ç¢
                pawnDirections = {}; // „Éù„Éº„É≥„ÅÆÂêë„ÅçÊÉÖÂ†±„ÇÇ„ÇØ„É™„Ç¢

                // **ÈßíIDÊÉÖÂ†±„Çí„ÇØ„É™„Ç¢**
                pieceIds = {};
                pieceIdCounter = 0; // „Ç´„Ç¶„É≥„Çø„Éº„ÇÇ„É™„Çª„ÉÉ„Éà

                document.querySelectorAll('.board-cell').forEach(cell => {
                    const piece = cell.querySelector('.placed-piece');
                    const blocked = cell.querySelector('.blocked-marker');
                    if (piece) piece.remove();
                    if (blocked) blocked.remove();
                    cell.classList.remove('occupied', 'blocked');
                });

                updateStats();
            }
        }

        // ÂàùÊúüÂåñ
        document.addEventListener('DOMContentLoaded', function() {
            initializeBoard();
            initializePalette();
            initializeScoreControls();
            updateStats();
        });
    </script>
</body>
</html>
