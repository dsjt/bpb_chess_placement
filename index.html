<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BackpackBattles ãƒã‚§ã‚¹é§’é…ç½®ãƒ„ãƒ¼ãƒ«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .tool-layout {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 30px;
            align-items: start;
        }

        .piece-palette {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }

        .palette-section {
            margin-bottom: 25px;
        }

        .palette-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }

        .piece-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }

        .piece-item {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: grab;
            transition: all 0.3s;
            user-select: none;
            position: relative;
        }

        .piece-item:hover {
            border-color: #667eea;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .piece-item:active {
            cursor: grabbing;
        }

        .piece-symbol {
            font-size: 32px;
            margin-bottom: 5px;
            display: block;
        }

        .piece-name {
            font-size: 12px;
            color: #666;
        }

        .white-piece {
            color: #333;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }

        .black-piece {
            color: #000;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .chess-board {
            background: #8B4513;
            border-radius: 15px;
            padding: 20px;
            display: inline-block;
            margin: 0 auto;
        }

        .board-grid {
            display: grid;
            grid-template-columns: repeat(9, 60px);
            grid-template-rows: repeat(7, 60px);
            gap: 2px;
        }

        .board-cell {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #654321;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .board-cell.light {
            background: #F0D9B5;
        }

        .board-cell.dark {
            background: #B58863;
        }

        .board-cell.drag-over {
            background: #FFE4B5 !important;
            border: 3px solid #FF6B35 !important;
            transform: scale(1.1);
        }

        .board-cell.occupied {
            background: #E8F5E8;
            border: 2px solid #28a745;
        }

        .board-cell.blocked {
            background: #8B0000 !important;
            border: 2px solid #FF4500 !important;
            position: relative;
        }

        .blocked-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .placed-piece {
            font-size: 40px;
            cursor: grab;
            transition: transform 0.2s;
            user-select: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .placed-piece:hover {
            transform: scale(1.2);
        }

        .placed-piece:active {
            cursor: grabbing;
        }

        .placed-piece.dragging {
            opacity: 0.5;
            transform: scale(0.8);
        }

        .info-panel {
            min-width:280px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .piece-count {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 5px 10px;
            background: white;
            border-radius: 5px;
            font-size: 14px;
        }

        .clear-button {
            width: 100%;
            padding: 12px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 10px;
        }

        .clear-button:hover {
            background: #c82333;
        }

        .score-controls {
            max-height: 1200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
        }

        .score-group {
            margin-bottom: 20px;
        }

        .score-label {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .piece-score-control {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .piece-icon {
            font-size: 20px;
            width: 30px;
            text-align: center;
        }

        .score-input-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .score-input-label {
            font-size: 10px;
            color: #666;
            text-align: center;
        }

        .score-input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
        }

        .score-input:focus {
            border-color: #667eea;
            outline: none;
        }

        .reset-button {
            width: 100%;
            padding: 8px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 10px;
        }

        .reset-button:hover {
            background: #5a6268;
        }

        .coordinates {
            position: absolute;
            font-size: 10px;
            color: #666;
            top: 2px;
            left: 2px;
        }

        .dragging-piece {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            font-size: 40px;
            transform: translate(-50%, -50%);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        @media (max-width: 1200px) {
            .tool-layout {
                grid-template-columns: 300px 1fr 300px;
                gap: 20px;
            }

            .chess-board {
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ° BackpackBattles ãƒã‚§ã‚¹é§’é…ç½®ãƒ„ãƒ¼ãƒ«</h1>

        <div class="tool-layout">
            <!-- å·¦å´: é§’ãƒ‘ãƒ¬ãƒƒãƒˆ -->
            <div class="piece-palette">
                <div class="palette-section">
                    <div class="palette-title">âšª ç™½é§’</div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="white-pawn">
                            <span class="piece-symbol white-piece">â™™</span>
                            <span class="piece-name">ãƒãƒ¼ãƒ³</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="white-knight">
                            <span class="piece-symbol white-piece">â™˜</span>
                            <span class="piece-name">ãƒŠã‚¤ãƒˆ</span>
                        </div>
                    </div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="white-bishop">
                            <span class="piece-symbol white-piece">â™—</span>
                            <span class="piece-name">ãƒ“ã‚·ãƒ§ãƒƒãƒ—</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="white-rook">
                            <span class="piece-symbol white-piece">â™–</span>
                            <span class="piece-name">ãƒ«ãƒ¼ã‚¯</span>
                        </div>
                    </div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="white-queen">
                            <span class="piece-symbol white-piece">â™•</span>
                            <span class="piece-name">ã‚¯ã‚¤ãƒ¼ãƒ³</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="white-king">
                            <span class="piece-symbol white-piece">â™”</span>
                            <span class="piece-name">ã‚­ãƒ³ã‚°</span>
                        </div>
                    </div>
                </div>

                <div class="palette-section">
                    <div class="palette-title">âš« é»’é§’</div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="black-pawn">
                            <span class="piece-symbol black-piece">â™Ÿ</span>
                            <span class="piece-name">ãƒãƒ¼ãƒ³</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="black-knight">
                            <span class="piece-symbol black-piece">â™</span>
                            <span class="piece-name">ãƒŠã‚¤ãƒˆ</span>
                        </div>
                    </div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="black-bishop">
                            <span class="piece-symbol black-piece">â™</span>
                            <span class="piece-name">ãƒ“ã‚·ãƒ§ãƒƒãƒ—</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="black-rook">
                            <span class="piece-symbol black-piece">â™œ</span>
                            <span class="piece-name">ãƒ«ãƒ¼ã‚¯</span>
                        </div>
                    </div>
                    <div class="piece-row">
                        <div class="piece-item" draggable="true" data-piece="black-queen">
                            <span class="piece-symbol black-piece">â™›</span>
                            <span class="piece-name">ã‚¯ã‚¤ãƒ¼ãƒ³</span>
                        </div>
                        <div class="piece-item" draggable="true" data-piece="black-king">
                            <span class="piece-symbol black-piece">â™š</span>
                            <span class="piece-name">ã‚­ãƒ³ã‚°</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ä¸­å¤®: ãƒã‚§ã‚¹ãƒœãƒ¼ãƒ‰ -->
            <div class="chess-board">
                <div class="board-grid" id="chessBoard">
                    <!-- ãƒœãƒ¼ãƒ‰ã¯JavaScriptã§ç”Ÿæˆ -->
                </div>
            </div>

            <!-- å³å´: æƒ…å ±ãƒ‘ãƒãƒ« -->
            <div class="info-panel">
                <div class="info-section">
                    <div class="info-title">ğŸ“Š é…ç½®çµ±è¨ˆ</div>
                    <div id="pieceStats">
                        <!-- çµ±è¨ˆæƒ…å ±ã¯JavaScriptã§æ›´æ–° -->
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">âš–ï¸ ã‚¹ã‚³ã‚¢è¨­å®š</div>
                    <div class="score-controls">
                        <div class="score-group">
                            <div class="score-label">ç™½é§’è¨­å®š</div>
                            <div id="whiteScoreControls"></div>
                        </div>
                        <div class="score-group">
                            <div class="score-label">é»’é§’è¨­å®š</div>
                            <div id="blackScoreControls"></div>
                        </div>
                        <button class="reset-button" onclick="resetScores()">ğŸ”„ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™</button>
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">ğŸ¯ æ“ä½œæ–¹æ³•</div>
                    <div style="font-size: 14px; line-height: 1.6;">
                        <p><strong>é…ç½®:</strong> å·¦ã®é§’ã‚’ãƒœãƒ¼ãƒ‰ã«ãƒ‰ãƒ©ãƒƒã‚°</p>
                        <p><strong>ç§»å‹•:</strong> ãƒœãƒ¼ãƒ‰ä¸Šã®é§’ã‚’ãƒ‰ãƒ©ãƒƒã‚°</p>
                        <p><strong>å‰Šé™¤:</strong> é§’ã‚’ãƒœãƒ¼ãƒ‰å¤–ã«ãƒ‰ãƒ©ãƒƒã‚°</p>
                        <p><strong>ç½®æ›:</strong> é§’ã®ä¸Šã«åˆ¥ã®é§’ã‚’ãƒ‰ãƒ­ãƒƒãƒ—</p>
                        <p><strong>ãƒãƒ¼ãƒ³å›è»¢:</strong> ãƒãƒ¼ãƒ³ã‚’å³ã‚¯ãƒªãƒƒã‚¯ã§å›è»¢</p>
                        <p><strong>é€²è¡Œä¸å¯:</strong> ç©ºãƒã‚¹ã‚’ä¸­ã‚¯ãƒªãƒƒã‚¯ã§åˆ‡æ›¿</p>
                    </div>
                </div>

                <button class="clear-button" onclick="clearBoard()">ğŸ—‘ï¸ ãƒœãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢</button>
            </div>
        </div>
    </div>

    <!-- ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®é§’è¡¨ç¤ºç”¨ -->
    <div id="draggingPiece" class="dragging-piece" style="display: none;"></div>

    <script>
        // é§’ã®å®šç¾©
        const pieceSymbols = {
            'white-pawn': 'â™™', 'white-knight': 'â™˜', 'white-bishop': 'â™—',
            'white-rook': 'â™–', 'white-queen': 'â™•', 'white-king': 'â™”',
            'black-pawn': 'â™Ÿ', 'black-knight': 'â™', 'black-bishop': 'â™',
            'black-rook': 'â™œ', 'black-queen': 'â™›', 'black-king': 'â™š'
        };

        const pieceNames = {
            'white-pawn': 'ç™½ãƒãƒ¼ãƒ³', 'white-knight': 'ç™½ãƒŠã‚¤ãƒˆ', 'white-bishop': 'ç™½ãƒ“ã‚·ãƒ§ãƒƒãƒ—',
            'white-rook': 'ç™½ãƒ«ãƒ¼ã‚¯', 'white-queen': 'ç™½ã‚¯ã‚¤ãƒ¼ãƒ³', 'white-king': 'ç™½ã‚­ãƒ³ã‚°',
            'black-pawn': 'é»’ãƒãƒ¼ãƒ³', 'black-knight': 'é»’ãƒŠã‚¤ãƒˆ', 'black-bishop': 'é»’ãƒ“ã‚·ãƒ§ãƒƒãƒ—',
            'black-rook': 'é»’ãƒ«ãƒ¼ã‚¯', 'black-queen': 'é»’ã‚¯ã‚¤ãƒ¼ãƒ³', 'black-king': 'é»’ã‚­ãƒ³ã‚°'
        };

        // ãƒœãƒ¼ãƒ‰çŠ¶æ…‹
        let board = Array(7).fill().map(() => Array(9).fill(null));
        let blockedCells = new Set(); // "row,col" å½¢å¼ã§é€²è¡Œä¸å¯èƒ½ã‚»ãƒ«ã‚’ç®¡ç†
        let draggedPiece = null;
        let draggedFromBoard = false;
        let draggedFromCell = null;

        // ãƒãƒ¼ãƒ³ã®å‘ãç®¡ç†ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ä¸Šå‘ãï¼‰
        let pawnDirections = {}; // key: "row,col", value: 0-3 (ä¸Šã€å³ã€ä¸‹ã€å·¦)

        // ãƒœãƒ¼ãƒ‰åˆæœŸåŒ–
        function initializeBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';

            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = `board-cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    // åº§æ¨™è¡¨ç¤º
                    const coords = document.createElement('span');
                    coords.className = 'coordinates';
                    coords.textContent = `${row},${col}`;
                    cell.appendChild(coords);

                    // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆ
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('drop', handleDrop);
                    cell.addEventListener('dragleave', handleDragLeave);

                    // å³ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒãƒ¼ãƒ³ã®å›è»¢ç”¨ï¼‰
                    cell.addEventListener('contextmenu', handleRightClick);

                    // ä¸­ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆé€²è¡Œä¸å¯èƒ½è¨­å®šç”¨ï¼‰
                    cell.addEventListener('mousedown', handleMouseDown);

                    boardElement.appendChild(cell);
                }
            }
        }

        // ãƒ‘ãƒ¬ãƒƒãƒˆã®é§’ã«ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
        function initializePalette() {
            document.querySelectorAll('.piece-item').forEach(item => {
                item.addEventListener('dragstart', handlePaletteDragStart);
                item.addEventListener('dragend', handleDragEnd);
            });
        }

        // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ã®ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
        function handlePaletteDragStart(e) {
            draggedPiece = e.target.dataset.piece;
            draggedFromBoard = false;

            const draggingElement = document.getElementById('draggingPiece');
            draggingElement.textContent = pieceSymbols[draggedPiece];
            draggingElement.className = `dragging-piece ${draggedPiece.includes('white') ? 'white-piece' : 'black-piece'}`;

            e.dataTransfer.effectAllowed = 'copy';

            // ãƒã‚¦ã‚¹è¿½å¾“
            document.addEventListener('mousemove', followMouse);
        }

        // ãƒœãƒ¼ãƒ‰ä¸Šã®é§’ã®ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
        function handleBoardDragStart(e) {
            const cell = e.target.closest('.board-cell');
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            draggedPiece = board[row][col];
            draggedFromBoard = true;
            draggedFromCell = { row, col };

            const draggingElement = document.getElementById('draggingPiece');
            draggingElement.textContent = pieceSymbols[draggedPiece];
            draggingElement.className = `dragging-piece ${draggedPiece.includes('white') ? 'white-piece' : 'black-piece'}`;

            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';

            document.addEventListener('mousemove', followMouse);
        }

        // ãƒã‚¦ã‚¹è¿½å¾“
        function followMouse(e) {
            const draggingElement = document.getElementById('draggingPiece');
            draggingElement.style.display = 'block';
            draggingElement.style.left = e.clientX + 'px';
            draggingElement.style.top = e.clientY + 'px';
        }

        // ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼
        function handleDragOver(e) {
            e.preventDefault();
            e.target.closest('.board-cell').classList.add('drag-over');
        }

        // ãƒ‰ãƒ©ãƒƒã‚°ãƒªãƒ¼ãƒ–
        function handleDragLeave(e) {
            e.target.closest('.board-cell').classList.remove('drag-over');
        }

        // ãƒ‰ãƒ­ãƒƒãƒ—
        function handleDrop(e) {
            e.preventDefault();
            const cell = e.target.closest('.board-cell');
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // é€²è¡Œä¸å¯èƒ½ã‚»ãƒ«ã«ã¯é…ç½®ã§ããªã„
            if (isBlocked(row, col)) {
                cell.classList.remove('drag-over');
                return;
            }

            // å…ƒã®ä½ç½®ã‹ã‚‰é§’ã‚’å‰Šé™¤ï¼ˆãƒœãƒ¼ãƒ‰ã‹ã‚‰ã®ç§»å‹•ã®å ´åˆï¼‰
            if (draggedFromBoard && draggedFromCell) {
                // **IDç§»è¡Œå‡¦ç†ã‚’è¿½åŠ **
                const fromKey = `${draggedFromCell.row},${draggedFromCell.col}`;
                const toKey = `${row},${col}`;

                // ç§»å‹•å…ƒã«IDãŒã‚ã‚Œã°ç§»å‹•å…ˆã«ç§»è¡Œ
                if (pieceIds[fromKey]) {
                    pieceIds[toKey] = pieceIds[fromKey];
                    delete pieceIds[fromKey];

                    // ãƒãƒ¼ãƒ³ã®å‘ãæƒ…å ±ã‚‚ä¸€ç·’ã«ç§»è¡Œ
                    if (pawnDirections[fromKey]) {
                        pawnDirections[toKey] = pawnDirections[fromKey];
                        delete pawnDirections[fromKey];
                    }
                }
                board[draggedFromCell.row][draggedFromCell.col] = null;
                updateCellDisplay(draggedFromCell.row, draggedFromCell.col);
            }

            // æ–°ã—ã„ä½ç½®ã«é§’ã‚’é…ç½®
            board[row][col] = draggedPiece;
            updateCellDisplay(row, col);

            cell.classList.remove('drag-over');
            updateStats();
        }

        // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
        function handleDragEnd(e) {
            document.removeEventListener('mousemove', followMouse);
            document.getElementById('draggingPiece').style.display = 'none';

            // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ
            document.querySelectorAll('.board-cell').forEach(cell => {
                cell.classList.remove('drag-over');
            });

            document.querySelectorAll('.placed-piece').forEach(piece => {
                piece.classList.remove('dragging');
            });

            // ãƒœãƒ¼ãƒ‰å¤–ã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ãŸå ´åˆã®å‰Šé™¤å‡¦ç†
            if (draggedFromBoard && draggedFromCell) {
                const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
                if (!dropTarget || !dropTarget.closest('.board-cell')) {
                    // ãƒœãƒ¼ãƒ‰å¤–ã«ãƒ‰ãƒ­ãƒƒãƒ— = å‰Šé™¤
                    board[draggedFromCell.row][draggedFromCell.col] = null;
                    updateCellDisplay(draggedFromCell.row, draggedFromCell.col);
                    updateStats();
                }
            }

            draggedPiece = null;
            draggedFromBoard = false;
            draggedFromCell = null;
        }

        // ã‚»ãƒ«ã®è¡¨ç¤ºã‚’æ›´æ–°
        function updateCellDisplay(row, col) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const existingPiece = cell.querySelector('.placed-piece');
            const existingBlocked = cell.querySelector('.blocked-marker');

            if (existingPiece) {
                existingPiece.remove();
            }
            if (existingBlocked) {
                existingBlocked.remove();
            }

            // é€²è¡Œä¸å¯èƒ½ã‚»ãƒ«ã®è¡¨ç¤º
            if (isBlocked(row, col)) {
                const blockedMarker = document.createElement('span');
                blockedMarker.className = 'blocked-marker';
                blockedMarker.textContent = 'â›”';
                cell.appendChild(blockedMarker);
                cell.classList.add('blocked');
                cell.classList.remove('occupied');
                return;
            } else {
                cell.classList.remove('blocked');
            }

            if (board[row][col]) {
                const piece = board[row][col];
                const pieceElement = document.createElement('span');
                pieceElement.className = `placed-piece ${piece.includes('white') ? 'white-piece' : 'black-piece'}`;

                const cellKey = `${row},${col}`;

                // æ–°è¦é…ç½®ã®å ´åˆã®ã¿IDä»˜ä¸
                if (!pieceIds[cellKey]) {
                    pieceIds[cellKey] = ++pieceIdCounter;
                }

                // ãƒãƒ¼ãƒ³ã®å ´åˆã¯å‘ãã‚’åæ˜ ã—ãŸè¡¨ç¤º
                if (piece.includes('pawn')) {
                    const pawnKey = `${row},${col}`;
                    const direction = pawnDirections[pawnKey] || 0;

                    // ãƒãƒ¼ãƒ³ã®åŸºæœ¬è¨˜å·ã‚’ä½¿ç”¨
                    pieceElement.textContent = pieceSymbols[piece];

                    // å‘ãã‚’è¦–è¦šçš„ã«ç¤ºã™ãŸã‚ã®å›è»¢
                    const rotations = ['0deg', '90deg', '180deg', '270deg'];
                    pieceElement.style.transform = `rotate(${rotations[direction]})`;
                    pieceElement.style.transformOrigin = 'center';
                    pieceElement.style.display = 'inline-block'; // å›è»¢ã®ãŸã‚ã«å¿…è¦
                } else {
                    pieceElement.textContent = pieceSymbols[piece];
                }

                pieceElement.draggable = true;

                pieceElement.addEventListener('dragstart', handleBoardDragStart);
                pieceElement.addEventListener('dragend', handleDragEnd);

                cell.appendChild(pieceElement);
                cell.classList.add('occupied');
            } else {
                // é§’ãŒå‰Šé™¤ã•ã‚ŒãŸå ´åˆã¯IDã‚‚å‰Šé™¤
                const cellKey = `${row},${col}`;
                delete pieceIds[cellKey];

                cell.classList.remove('occupied');
            }
        }
        let pieceIdCounter = 0;
        let pieceIds = {}; // (row,col) -> unique_id ã®ãƒãƒƒãƒ”ãƒ³ã‚°

        function assignPieceId(row, col) {
            const key = `${row},${col}`;
            if (!pieceIds[key]) {
                pieceIds[key] = ++pieceIdCounter;
            }
            return pieceIds[key];
        }

        function movePieceWithId(fromRow, fromCol, toRow, toCol) {
            const fromKey = `${fromRow},${fromCol}`;
            const toKey = `${toRow},${toCol}`;

            // IDã‚’æ–°ã—ã„ä½ç½®ã«ç§»è¡Œ
            if (pieceIds[fromKey]) {
                pieceIds[toKey] = pieceIds[fromKey];
                delete pieceIds[fromKey];
            }
        }

        // ä¸­ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆé€²è¡Œä¸å¯èƒ½è¨­å®šï¼‰
        function handleMouseDown(e) {
            if (e.button === 1) { // ä¸­ã‚¯ãƒªãƒƒã‚¯
                e.preventDefault();
                const cell = e.target.closest('.board-cell');
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                toggleBlockedCell(row, col);
            }
        }

        // ä¸­ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆé€²è¡Œä¸å¯èƒ½è¨­å®šï¼‰
        function handleMouseDown(e) {
            if (e.button === 1) { // ä¸­ã‚¯ãƒªãƒƒã‚¯
                e.preventDefault();
                const cell = e.target.closest('.board-cell');
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                toggleBlockedCell(row, col);
            }
        }

        // é€²è¡Œä¸å¯èƒ½ã‚»ãƒ«ã®åˆ‡ã‚Šæ›¿ãˆ
        function toggleBlockedCell(row, col) {
            const cellKey = `${row},${col}`;

            if (isBlocked(row, col)) {
                // é€²è¡Œä¸å¯èƒ½ã‚’è§£é™¤
                blockedCells.delete(cellKey);
            } else {
                // é§’ãŒã‚ã‚‹å ´åˆã¯å…ˆã«é§’ã‚’å‰Šé™¤
                if (board[row][col]) {
                    board[row][col] = null;
                    // ãƒãƒ¼ãƒ³ã®å‘ãæƒ…å ±ã‚‚å‰Šé™¤
                    delete pawnDirections[cellKey];
                }
                // é€²è¡Œä¸å¯èƒ½ã«è¨­å®š
                blockedCells.add(cellKey);
            }

            updateCellDisplay(row, col);
            updateStats();
        }

        // å³ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒãƒ¼ãƒ³ã®å›è»¢ï¼‰
        function handleRightClick(e) {
            e.preventDefault(); // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã—ãªã„

            const cell = e.target.closest('.board-cell');
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const piece = board[row][col];

            // ãƒãƒ¼ãƒ³ã®å ´åˆã®ã¿å›è»¢å‡¦ç†
            if (piece && piece.includes('pawn')) {
                const pawnKey = `${row},${col}`;
                const currentDirection = pawnDirections[pawnKey] || 0;

                // æ™‚è¨ˆå›ã‚Šã«å›è»¢ï¼ˆ0â†’1â†’2â†’3â†’0ï¼‰
                pawnDirections[pawnKey] = (currentDirection + 1) % 4;

                // è¡¨ç¤ºã‚’æ›´æ–°
                updateCellDisplay(row, col);

                // è©•ä¾¡ã‚’å†è¨ˆç®—
                updateStats();
            }
        }

        // é§’ã®ä¾¡å€¤å®šç¾©ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼‰
        const defaultPieceValues = {
            'white-pawn': [1, 1], 'white-knight': [3, 3], 'white-bishop': [3, 3],
            'white-rook': [5, 5], 'white-queen': [9, 9], 'white-king': [4, 2],
            'black-pawn': [1, 1], 'black-knight': [3, 3], 'black-bishop': [3, 3],
            'black-rook': [5, 5], 'black-queen': [9, 9], 'black-king': [4, 2]
        };

        // ç¾åœ¨ã®é§’ã®ä¾¡å€¤ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤‰æ›´å¯èƒ½ï¼‰
        let pieceValues = JSON.parse(JSON.stringify(defaultPieceValues));

        const pieceTypeNames = {
            'pawn': 'ãƒãƒ¼ãƒ³',
            'knight': 'ãƒŠã‚¤ãƒˆ',
            'bishop': 'ãƒ“ã‚·ãƒ§ãƒƒãƒ—',
            'rook': 'ãƒ«ãƒ¼ã‚¯',
            'queen': 'ã‚¯ã‚¤ãƒ¼ãƒ³',
            'king': 'ã‚­ãƒ³ã‚°'
        };

        // ã‚¹ã‚³ã‚¢è¨­å®šUIã®åˆæœŸåŒ–
        function initializeScoreControls() {
            const whiteContainer = document.getElementById('whiteScoreControls');
            const blackContainer = document.getElementById('blackScoreControls');

            const pieceTypes = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'];

            pieceTypes.forEach(type => {
                // ç™½é§’ç”¨
                const whiteDiv = document.createElement('div');
                whiteDiv.className = 'piece-score-control';

                if (type === 'king') {
                    // ã‚­ãƒ³ã‚°ã¯è‡ªè»åŠ¹æœã®è¨­å®š
                    whiteDiv.innerHTML = `
                        <div class="piece-icon white-piece">${pieceSymbols['white-' + type]}</div>
                        <div class="score-input-group">
                            <div class="score-input-label">å–ã‚‹æ™‚</div>
                            <input type="number" class="score-input" id="white-${type}-capture"
                                   value="${pieceValues['white-' + type][0]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('white-${type}', 0, this.value)">
                        </div>
                        <div class="score-input-group">
                            <div class="score-input-label">è‡ªè»åŠ¹æœ</div>
                            <input type="number" class="score-input" id="white-${type}-captured"
                                   value="${pieceValues['white-' + type][1]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('white-${type}', 1, this.value)">
                        </div>
                    `;
                } else {
                    whiteDiv.innerHTML = `
                        <div class="piece-icon white-piece">${pieceSymbols['white-' + type]}</div>
                        <div class="score-input-group">
                            <div class="score-input-label">å–ã‚‹æ™‚</div>
                            <input type="number" class="score-input" id="white-${type}-capture"
                                   value="${pieceValues['white-' + type][0]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('white-${type}', 0, this.value)">
                        </div>
                        <div class="score-input-group">
                            <div class="score-input-label">å–ã‚‰ã‚Œã‚‹æ™‚</div>
                            <input type="number" class="score-input" id="white-${type}-captured"
                                   value="${pieceValues['white-' + type][1]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('white-${type}', 1, this.value)">
                        </div>
                    `;
                }
                whiteContainer.appendChild(whiteDiv);

                // é»’é§’ç”¨
                const blackDiv = document.createElement('div');
                blackDiv.className = 'piece-score-control';

                if (type === 'king') {
                    // ã‚­ãƒ³ã‚°ã¯è‡ªè»åŠ¹æœã®è¨­å®š
                    blackDiv.innerHTML = `
                        <div class="piece-icon black-piece">${pieceSymbols['black-' + type]}</div>
                        <div class="score-input-group">
                            <div class="score-input-label">å–ã‚‹æ™‚</div>
                            <input type="number" class="score-input" id="black-${type}-capture"
                                   value="${pieceValues['black-' + type][0]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('black-${type}', 0, this.value)">
                        </div>
                        <div class="score-input-group">
                            <div class="score-input-label">è‡ªè»åŠ¹æœ</div>
                            <input type="number" class="score-input" id="black-${type}-captured"
                                   value="${pieceValues['black-' + type][1]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('black-${type}', 1, this.value)">
                        </div>
                    `;
                } else {
                    blackDiv.innerHTML = `
                        <div class="piece-icon black-piece">${pieceSymbols['black-' + type]}</div>
                        <div class="score-input-group">
                            <div class="score-input-label">å–ã‚‹æ™‚</div>
                            <input type="number" class="score-input" id="black-${type}-capture"
                                   value="${pieceValues['black-' + type][0]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('black-${type}', 0, this.value)">
                        </div>
                        <div class="score-input-group">
                            <div class="score-input-label">å–ã‚‰ã‚Œã‚‹æ™‚</div>
                            <input type="number" class="score-input" id="black-${type}-captured"
                                   value="${pieceValues['black-' + type][1]}" min="0" max="20" step="1"
                                   onchange="updatePieceValue('black-${type}', 1, this.value)">
                        </div>
                    `;
                }
                blackContainer.appendChild(blackDiv);
            });
        }

        // é§’ã®ä¾¡å€¤æ›´æ–°
        function updatePieceValue(pieceKey, valueIndex, newValue) {
            const value = parseFloat(newValue) || 0;
            pieceValues[pieceKey][valueIndex] = value;
            updateStats(); // çµ±è¨ˆã‚’å†è¨ˆç®—
        }

        // ã‚¹ã‚³ã‚¢ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãƒªã‚»ãƒƒãƒˆ
        function resetScores() {
            if (confirm('åŠ¹æœå€¤ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ')) {
                pieceValues = JSON.parse(JSON.stringify(defaultPieceValues));

                // UIæ›´æ–°
                Object.keys(pieceValues).forEach(pieceKey => {
                    const [color, type] = pieceKey.split('-');
                    document.getElementById(`${color}-${type}-capture`).value = pieceValues[pieceKey][0];
                    document.getElementById(`${color}-${type}-captured`).value = pieceValues[pieceKey][1];
                });

                updateStats();
            }
        }

        // é§’ã®ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³å–å¾—
        function getPossibleMoves(piece, row, col, currentBoard = board, currentPawnDirections = pawnDirections) {
            const moves = [];
            const pieceType = piece.split('-')[1];

            switch (pieceType) {
                case 'pawn':
                    // ãƒãƒ¼ãƒ³: å‘ãã«å¿œã˜ãŸæ–œã‚å‰2æ–¹å‘
                    const pawnKey = `${row},${col}`;
                    const direction = currentPawnDirections[pawnKey] || 0; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ä¸Šå‘ã

                    // å‘ãã”ã¨ã®æ–œã‚å‰æ–¹å‘å®šç¾©
                    const pawnDirectionMoves = [
                        [[-1, -1], [-1, 1]], // ä¸Šå‘ã
                        [[1, 1], [-1, 1]],   // å³å‘ã
                        [[1, -1], [1, 1]],   // ä¸‹å‘ã
                        [[-1, -1], [1, -1]]  // å·¦å‘ã
                    ];

                    const pawnMoves = pawnDirectionMoves[direction];
                    pawnMoves.forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (isValidPosition(newRow, newCol) && !isBlocked(newRow, newCol)) {
                            const targetPiece = currentBoard[newRow][newCol];
                            if (!targetPiece || getColor(targetPiece) !== getColor(piece)) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    });
                    break;

                case 'knight':
                    // ãƒŠã‚¤ãƒˆ: Lå­—ç§»å‹•
                    const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                    knightMoves.forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (isValidPosition(newRow, newCol) && !isBlocked(newRow, newCol)) {
                            const targetPiece = currentBoard[newRow][newCol];
                            if (!targetPiece || getColor(targetPiece) !== getColor(piece)) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    });
                    break;

                case 'bishop':
                    // ãƒ“ã‚·ãƒ§ãƒƒãƒ—: æ–œã‚
                addSlidingMoves(moves, row, col, [[-1,-1], [-1,1], [1,-1], [1,1]], piece, currentBoard);
                    break;

                case 'rook':
                    // ãƒ«ãƒ¼ã‚¯: å‰å¾Œå·¦å³
                addSlidingMoves(moves, row, col, [[-1,0], [1,0], [0,-1], [0,1]], piece, currentBoard);
                    break;

                case 'queen':
                    // ã‚¯ã‚¤ãƒ¼ãƒ³: å…¨æ–¹å‘
                addSlidingMoves(moves, row, col, [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]], piece, currentBoard);
                    break;

                case 'king':
                    // ã‚­ãƒ³ã‚°: å…¨æ–¹å‘1ãƒã‚¹
                    const kingMoves = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
                    kingMoves.forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (isValidPosition(newRow, newCol) && !isBlocked(newRow, newCol)) {
                            const targetPiece = currentBoard[newRow][newCol];
                            if (!targetPiece || getColor(targetPiece) !== getColor(piece)) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    });
                    break;
            }

            return moves;
        }

        function addSlidingMoves(moves, row, col, directions, piece, currentBoard = board) {
            directions.forEach(([dr, dc]) => {
                for (let i = 1; i < 9; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;

                    // ç›¤é¢å¤–ãªã‚‰åœæ­¢
                    if (!isValidPosition(newRow, newCol)) break;

                    // é€²è¡Œä¸å¯èƒ½ãƒã‚¹ã«ã¯ç§»å‹•ã§ããªã„ãŒã€é€šéã¯å¯èƒ½
                    if (!isBlocked(newRow, newCol)) {
                        const targetPiece = currentBoard[newRow][newCol];
                        if (!targetPiece || getColor(targetPiece) !== getColor(piece)) {
                            moves.push([newRow, newCol]);
                        }
                    }
                    // é§’ãŒã‚ã£ã¦ã‚‚é£›ã³è¶Šãˆã¦ç§»å‹•å¯èƒ½ï¼ˆBackpackBattlesãƒ«ãƒ¼ãƒ«ï¼‰
                }
            });
        }

        function isValidPosition(row, col) {
            return row >= 0 && row < 7 && col >= 0 && col < 9;
        }

        function isBlocked(row, col) {
            return blockedCells.has(`${row},${col}`);
        }

        function getColor(piece) {
            return piece ? piece.split('-')[0] : null;
        }

        function getOppositeColor(color) {
            return color === 'white' ? 'black' : 'white';
        }

        function logAllPieces(currentBoard) {
            console.log("=== ç¾åœ¨ã®ç›¤é¢ã®é§’ä¸€è¦§ ===");
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = currentBoard[row][col];
                    if (piece) {
                        console.log(`${piece} at (${row}, ${col})`);
                    }
                }
            }
        }

        // ç›¤é¢è©•ä¾¡é–¢æ•°
        function evaluateBoard(boardState = null, pawnState = null, depth = 0, turn = 'white', maxDepth = 3, firstCapture = null) {
            if (depth >= maxDepth) return 0;

            const currentBoard = boardState || board;
            const currentPawnDirections = pawnState || pawnDirections;
            let totalScore = 0;
            let candidateNum = 0;

            // åˆå›æˆ¦é—˜ãƒ•ãƒ©ã‚°ã®åˆæœŸåŒ–ï¼ˆå€‹åˆ¥é§’ã”ã¨ï¼‰
            if (firstCapture === null) {
                firstCapture = new Set();
            }

            // æŒ‡å®šè‰²ã®å…¨é§’ã«ã¤ã„ã¦è©•ä¾¡
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = currentBoard[row][col];
                    if (!piece || getColor(piece) !== turn) continue;

                    const moves = getPossibleMoves(piece, row, col, currentBoard, currentPawnDirections);

                    for (const [newRow, newCol] of moves) {
                        const eliminatePiece = currentBoard[newRow][newCol];
                        if (eliminatePiece) {
                            candidateNum++;

                            // ã‚¹ã‚³ã‚¢è¨ˆç®—
                            let score = 0;

                            // å–ã‚‹é§’ã®åŸºæœ¬åŠ¹æœ
                            score += pieceValues[piece][0];

                            // ã‚­ãƒ³ã‚°ã¯å–ã‚‰ã‚Œã‚‹åŠ¹æœãªã—ã€ãã®ä»–ã¯å–ã‚‰ã‚Œã‚‹åŠ¹æœã‚ã‚Š
                            if (!eliminatePiece.includes('king')) {
                                score += pieceValues[eliminatePiece][1];
                            }

                            // ã‚­ãƒ³ã‚°ã®è‡ªè»åŠ¹æœã‚’ãƒã‚§ãƒƒã‚¯
                            let countKingSupport = countAllyKings(currentBoard, getColor(piece));

                            if (countKingSupport > 0) {
                                // ã‚­ãƒ³ã‚°ã®è‡ªè»åŠ¹æœã‚’è¿½åŠ 
                                const kingPiece = getColor(piece) === 'white' ? 'white-king' : 'black-king';
                                const kingBonus = countKingSupport * pieceValues[kingPiece][1]; // ã‚­ãƒ³ã‚°ã®è‡ªè»åŠ¹æœã¯[1]ã«è¨­å®š

                                // å€‹åˆ¥é§’ã®åˆå›æˆ¦é—˜ã®å ´åˆã¯2å€
                                const cellKey = `${row},${col}`;
                                const pieceId = pieceIds[cellKey];
                                const firstCaptureKey = `${pieceId}`;

                                if (pieceId && !firstCapture.has(firstCaptureKey)) {
                                    score += kingBonus * 2;
                                    // æ–°ã—ã„Setã‚’ä½œæˆã—ã¦çŠ¶æ…‹ã‚’æ›´æ–°
                                    const newFirstCapture = new Set(firstCapture);
                                    newFirstCapture.add(firstCaptureKey);

                                    // ç›¤é¢ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ç§»å‹•ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                                    const newBoard = currentBoard.map(row => [...row]);
                                    const newPawnDirections = { ...currentPawnDirections}
                                    if (piece.includes('pawn')){
                                        newBoard[newRow][newCol] = piece;
                                        newBoard[row][col] = null;
                                        newPawnDirections[`${newRow},${newCol}`] = newPawnDirections[`${row},${col}`];
                                        delete newPawnDirections[`${row},${col}`];
                                    } else {
                                        newBoard[newRow][newCol] = piece;
                                        newBoard[row][col] = null;
                                    }

                                    // å†å¸°è©•ä¾¡ï¼ˆæ›´æ–°ã•ã‚ŒãŸåˆå›æˆ¦é—˜ãƒ•ãƒ©ã‚°ã‚’å¼•ãç¶™ãï¼‰
                                    score += evaluateBoard(newBoard, newPawnDirectory, depth+1, getOppositeColor(turn), maxDepth, newFirstCapture);
                                } else {
                                    score += kingBonus;

                                    // ç›¤é¢ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ç§»å‹•ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                                    const newBoard = currentBoard.map(row => [...row]);
                                    const newPawnDirections = { ...currentPawnDirections}
                                    if (piece.includes('pawn')){
                                        newBoard[newRow][newCol] = piece;
                                        newBoard[row][col] = null;
                                        newPawnDirections[`${newRow},${newCol}`] = newPawnDirections[`${row},${col}`];
                                        delete newPawnDirections[`${row},${col}`];
                                    } else {
                                        newBoard[newRow][newCol] = piece;
                                        newBoard[row][col] = null;
                                    }
                                    // å†å¸°è©•ä¾¡
                                    score += evaluateBoard(newBoard, newPawnDirections, depth+1, getOppositeColor(turn), maxDepth, new Set(firstCapture));
                                }
                            } else {
                                // ã‚­ãƒ³ã‚°ã‚µãƒãƒ¼ãƒˆãªã—ã®å ´åˆ
                                // ç›¤é¢ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ç§»å‹•ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                                const newBoard = currentBoard.map(row => [...row]);
                                const newPawnDirections = { ...currentPawnDirections};
                                if (piece.includes('pawn')){
                                    newBoard[newRow][newCol] = piece;
                                    newBoard[row][col] = null;
                                    newPawnDirections[`${newRow},${newCol}`] = newPawnDirections[`${row},${col}`];
                                    delete newPawnDirections[`${row},${col}`];
                                } else {
                                    newBoard[newRow][newCol] = piece;
                                    newBoard[row][col] = null;
                                }

                                // å†å¸°è©•ä¾¡
                                score += evaluateBoard(newBoard, newPawnDirections, depth+1, getOppositeColor(turn), maxDepth, new Set(firstCapture));
                            }

                            totalScore += score;
                        }
                    }
                }
            }


            // å–å¾—ã§ãã‚‹ç§»å‹•å…ˆãŒãªã„å ´åˆ
            if (candidateNum == 0) {
                // ãƒ©ãƒ³ãƒ€ãƒ ã«ç§»å‹•
                // æŒ‡å®šè‰²ã®å…¨é§’ã«ã¤ã„ã¦è©•ä¾¡
                for (let row = 0; row < 7; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = currentBoard[row][col];
                        if (!piece || getColor(piece) !== turn) continue;
                        const moves = getPossibleMoves(piece, row, col, currentBoard, currentPawnDirections);

                        for (const [newRow, newCol] of moves) {
                            candidateNum++;

                            // ç›¤é¢ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ç§»å‹•ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                            const newBoard = currentBoard.map(row => [...row]);
                            const newPawnDirections = { ...currentPawnDirections};
                            if (piece.includes('pawn')){
                                newBoard[newRow][newCol] = piece;
                                newBoard[row][col] = null;
                                newPawnDirections[`${newRow},${newCol}`] = newPawnDirections[`${row},${col}`];
                                delete newPawnDirections[`${row},${col}`];
                            } else {
                                newBoard[newRow][newCol] = piece;
                                newBoard[row][col] = null;
                            }
                            // å†å¸°è©•ä¾¡
                            let score = 0;
                            score += evaluateBoard(newBoard, newPawnDirections, depth+1, getOppositeColor(turn), maxDepth, new Set(firstCapture));
                            totalScore += score;
                        }
                    }
                }
            }
            if (candidateNum > 0){
                totalScore /= candidateNum
                return totalScore;
            }

            // ç§»å‹•ã§ãã‚‹é§’ãŒãªã„å ´åˆ
            let score = 0;
            const newBoard = currentBoard.map(row => [...row]);
            score += evaluateBoard(newBoard, { ... currentPawnDirections}, depth+1, getOppositeColor(turn), maxDepth, new Set(firstCapture));
            totalScore += score;

            return totalScore;
        }

        // è‡ªè»ã‚­ãƒ³ã‚°ã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
        function countAllyKings(boardState, color) {
            let kingCount = 0;
            // ç›¤é¢å…¨ä½“ã§è‡ªè»ã‚­ãƒ³ã‚°ã‚’æ¢ç´¢
            for (let r = 0; r < 7; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = boardState[r][c];
                    if (piece && piece.includes('king') && getColor(piece) === color) {
                        kingCount++;
                    }
                }
            }
            return kingCount;
        }

        // çµ±è¨ˆæ›´æ–°
        function updateStats() {
            const stats = {};
            const colors = { white: 0, black: 0 };

            // é§’ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col]) {
                        const piece = board[row][col];
                        stats[piece] = (stats[piece] || 0) + 1;

                        if (piece.includes('white')) colors.white++;
                        else colors.black++;
                    }
                }
            }

            // ç›¤é¢è©•ä¾¡ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆç™½æ‰‹ç•ªé–‹å§‹ï¼‰
            const boardScore = evaluateBoard(null, null, 0, 'white', 5);

            // çµ±è¨ˆè¡¨ç¤ºã‚’æ›´æ–°
            const statsElement = document.getElementById('pieceStats');
            let html = '';

            // è‰²åˆ¥çµ±è¨ˆ
            html += `<div class="piece-count"><strong>ç™½é§’ç·æ•°:</strong> <span>${colors.white}</span></div>`;
            html += `<div class="piece-count"><strong>é»’é§’ç·æ•°:</strong> <span>${colors.black}</span></div>`;
            html += `<div class="piece-count"><strong>ãƒãƒ©ãƒ³ã‚¹å·®:</strong> <span>${Math.abs(colors.white - colors.black)}</span></div>`;

            html += '<hr style="margin: 10px 0;">';

            // ç›¤é¢è©•ä¾¡ã‚¹ã‚³ã‚¢
            html += `<div class="piece-count"><strong>ç›¤é¢è©•ä¾¡:</strong> <span>${boardScore.toFixed(1)}</span></div>`;

            html += '<hr style="margin: 10px 0;">';

            // å€‹åˆ¥é§’çµ±è¨ˆ
            Object.keys(pieceNames).forEach(piece => {
                if (stats[piece]) {
                    html += `<div class="piece-count">
                        <span>${pieceNames[piece]}:</span>
                        <span>${stats[piece]}</span>
                    </div>`;
                }
            });

            statsElement.innerHTML = html;
        }

        // ãƒœãƒ¼ãƒ‰ã‚¯ãƒªã‚¢
        function clearBoard() {
            if (confirm('ãƒœãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                board = Array(7).fill().map(() => Array(9).fill(null));
                blockedCells.clear(); // é€²è¡Œä¸å¯èƒ½ã‚»ãƒ«æƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                pawnDirections = {}; // ãƒãƒ¼ãƒ³ã®å‘ãæƒ…å ±ã‚‚ã‚¯ãƒªã‚¢

                // **é§’IDæƒ…å ±ã‚’ã‚¯ãƒªã‚¢**
                pieceIds = {};
                pieceIdCounter = 0; // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚‚ãƒªã‚»ãƒƒãƒˆ

                document.querySelectorAll('.board-cell').forEach(cell => {
                    const piece = cell.querySelector('.placed-piece');
                    const blocked = cell.querySelector('.blocked-marker');
                    if (piece) piece.remove();
                    if (blocked) blocked.remove();
                    cell.classList.remove('occupied', 'blocked');
                });

                updateStats();
            }
        }

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeBoard();
            initializePalette();
            initializeScoreControls();
            updateStats();
        });
    </script>
</body>
</html>
